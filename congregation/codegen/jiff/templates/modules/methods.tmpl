(function (exports) {

  exports._bubbleSort = async function(inRel, keepRows, keyCol, jiffInstance, numCols, minVal, maxVal) {
    let loop = jiffInstance.start_barrier();
    for (let i = minVal; i < maxVal; i++) {
      let a = inRel[i][keyCol];
      let b = inRel[i+1][keyCol];
      let cmp = a.slt(b);

      for (let j = 0; j < numCols; j++) {
        let tempOne = cmp.if_else(inRel[i][j], inRel[i+1][j]);
        let tempTwo = cmp.if_else(inRel[i+1][j], inRel[i][j]);

        inRel[i][j] = tempOne;
        inRel[i+1][j] = tempTwo;
      }

      let keepOne = cmp.if_else(keepRows[i], keepRows[i+1]);
      let keepTwo = cmp.if_else(keepRows[i+1], keepRows[i]);

      keepRows[i] = keepOne;
      keepRows[i+1] = keepTwo;
    }
    await jiffInstance.end_barrier(loop);
  }

  exports.bubbleSort = async function(inRel, keepRows, keyCol, jiffInstance) {

    let numCols = inRel[0].length;
    for (let i = 0; i < inRel.length; i++) {
      let minVal;
      let maxVal;

      let totalRows = inRel.length - i - 1;
      let chunks = Math.floor(totalRows/20);
      if (chunks > 0) {
        for (let j = 0; j < chunks; j++) {
          minVal = 20 * j;
          maxVal = minVal + 20;
          await exports._bubbleSort(inRel, keepRows, keyCol, jiffInstance, numCols, minVal, maxVal);
        }
        // finish last bit
        await exports._bubbleSort(inRel, keepRows, keyCol, jiffInstance, numCols, maxVal, totalRows);
      } else {
        await exports._bubbleSort(inRel, keepRows, keyCol, jiffInstance, numCols, 0, totalRows);
      }
    }
    return [inRel, keepRows];
  }

  exports.open = function (inRel, keepRows, jiffInstance) {

    let results = jiffInstance.open_ND_array(inRel);
    let keepRowsResult = jiffInstance.open_array(keepRows);

    return Promise.all([results, keepRowsResult]).then(function (arr) {
      let openedRes = arr[0];
      let openedKeep = arr[1];
      let ret = [];

      for (let i = 0; i < openedRes.length; i++) {
        if (Number(openedKeep[i])) {
          ret.push(openedRes[i]);
        }
      }

      return ret;
    });
  };

  exports.concat = function (inRels, keepRows) {

    let ret = [];
    let keepRowsResult = [];
    for (let i = 0; i < inRels.length; i++) {
      for (let j = 0; j < inRels[i].length; j++) {
        ret.push(inRels[i][j]);
        keepRowsResult.push(keepRows[i][j]);
      }
    }

    return [ret, keepRowsResult];
  }

  let _aggregateSum = async function (inRel, keepRows, keyCol, aggCol, jiffInstance) {

    let newRel = [];
    for (let i = 0; i < inRel.length; i++) {
      newRel.push([inRel[i][keyCol], inRel[i][aggCol]]);
    }

    let sorted = await exports.bubbleSort(newRel, keepRows, keyCol, jiffInstance);
    let sortedData = sorted[0];
    let sortedKeepRows = sorted[1];

    for (let i = 0; i < sortedData.length - 1; i++) {
      let step = jiffInstance.start_barrier();

      let a = sortedData[i][keyCol];
      let b = sortedData[i+1][keyCol];
      let dataCmp = a.eq(b);

      let temp = dataCmp.if_else(sortedData[i][aggCol].sadd(sortedData[i+1][aggCol]), sortedData[i+1][aggCol]);
      let bothKeep = sortedKeepRows[i].smult(sortedKeepRows[i+1]);
      let dataKeep = dataCmp.smult(bothKeep);
      let tempResult = bothKeep.if_else(temp, sortedData[i+1][aggCol]);
      let tempKeep = dataKeep.if_else(keyCol, keepRows[i]);

      sortedData[i+1][aggCol] = tempResult;
      sortedKeepRows[i] = tempKeep;

      await jiffInstance.end_barrier(step);
    }

    return [sortedData, sortedKeepRows];
  }

  exports.aggregateSum = async function (inRel, keepRows, keyCol, aggCol, jiffInstance) {

    if (keyCol !== null) {
      return await _aggregateSum(inRel, keepRows, keyCol, aggCol, jiffInstance);
    } else {
      let ret = inRel[0][aggCol];
      for (let i = 1; i < inRel.length; i++) {
        ret = ret.sadd(inRel[i][aggCol]);
      }

      return [[[ret]], [keepRows[0]]];
    }
  }

  exports.numRows = function (keepRows) {

    let ret = keepRows[0];
    for (let i = 1; i < keepRows.length; i++) {
      ret = ret.sadd(keepRows[i]);
    }

    // if return value is greater than 0, at least 1 row was valid.
    let keepRowsResult = ret.gteq(1);

    return [[[ret]], [keepRowsResult]];
  }

}(typeof exports === 'undefined' ? this.methods = {} : exports));