(function (exports) {

  exports._aggregateCount = async function (inRel, keepRows, keyCol, jiffInstance) {

    let newRel = [];
    for (let i = 0; i < inRel.length; i++) {
      newRel.push([inRel[i][keyCol], keepRows[i]]);
    }

    return await exports._aggregateSum(newRel, keepRows, 0, 1, jiffInstance);
  }

  exports.aggregateCount = async function (inRel, keepRows, keyCol, jiffInstance) {

    if (keyCol !== null) {
      return await exports._aggregateCount(inRel, keepRows, keyCol, jiffInstance);
    } else {
      return exports.numRows(keepRows);
    }
  }

  exports._aggregateSum = async function (inRel, keepRows, keyCol, aggCol, jiffInstance) {

    let newRel = [];
    for (let i = 0; i < inRel.length; i++) {
      newRel.push([inRel[i][keyCol], inRel[i][aggCol]]);
    }

    let sorted = await exports.bubbleSort(newRel, keepRows, keyCol, jiffInstance);
    let sortedData = sorted[0];
    let sortedKeepRows = sorted[1];

    for (let i = 0; i < sortedData.length - 1; i++) {
      let step = jiffInstance.start_barrier();

      let a = sortedData[i][0];
      let b = sortedData[i+1][0];
      let dataCmp = a.eq(b);

      let temp = dataCmp.if_else(sortedData[i][1].sadd(sortedData[i+1][1]), sortedData[i+1][1]);
      let bothKeep = sortedKeepRows[i].smult(sortedKeepRows[i+1]);
      let dataKeep = dataCmp.smult(bothKeep);
      let tempResult = bothKeep.if_else(temp, sortedData[i+1][1]);
      let tempKeep = dataKeep.if_else(keyCol, keepRows[i]);

      sortedData[i+1][aggCol] = tempResult;
      sortedKeepRows[i] = tempKeep;

      await jiffInstance.end_barrier(step);
    }

    return [sortedData, sortedKeepRows];
  }

  exports.aggregateSum = async function (inRel, keepRows, keyCol, aggCol, jiffInstance) {

    if (keyCol !== null) {
      return await exports._aggregateSum(inRel, keepRows, keyCol, aggCol, jiffInstance);
    } else {

      let ret = inRel[0][aggCol].smult(keepRows[0]);
      let keepRowsSum = keepRows[0];
      for (let i = 1; i < inRel.length; i++) {

        let temp = inRel[i][aggCol].smult(keepRows[i]);
        ret = ret.sadd(temp);
        keepRowsSum = keepRowsSum.sadd(keepRows[i]);
      }

      let keepRowsResult = keepRowsSum.gteq(1);

      return [[[ret]], [keepRowsResult]];
    }
  }

  exports.project = function (inRel, keepRows, selectedCols) {

    let ret = [];
    let keepRowsResult = [];

    for (let i = 0; i < inRel.length; i++) {
      ret.push([]);
      keepRowsResult.push(keepRows[i]);
      for (let j = 0; j < selectedCols.length; j++) {
        ret[i].push(inRel[i][selectedCols[j]]);
      }
    }

    return [ret, keepRowsResult];
  }

  exports.multiply = function (inRel, keepRows, colOperands, scalarOperands, targetCol, newCol) {

    let ret = [];
    let keepRowsResult = [];

    for (let i = 0; i < inRel.length; i++) {
      keepRowsResult.push([keepRows[i]]);

      let targetVal;
      let k;
      if (newCol) {
        // if newCol is true, there will be at least one colOperand
        targetVal = inRel[i][colOperands[0]];
        k = 1;
      } else {
        targetVal = inRel[i][targetCol];
        k = 0;
      }

      for (let j = 0; j < scalarOperands.length; j++) {
        targetVal = targetVal.cmult(scalarOperands[j]);
      }
      for (k; k < colOperands.length; k++) {
        targetVal = targetVal.smult(inRel[i][colOperands[k]]);
      }

      if (newCol) {
        let newRow = inRel[i].concat([targetVal]);
        ret.push(newRow);
      } else {
        inRel[i][targetCol] = targetVal;
        ret.push(inRel[i]);
      }
    }

    return [ret, keepRowsResult];
  }

  exports.divide = function (inRel, keepRows, operands, targetCol, newCol) {

    let ret = [];
    let keepRowsResult = [];

    for (let i = 0; i < inRel.length; i++) {
      keepRowsResult.push(keepRows[i]);

      let targetVal;
      if (newCol) {
        // if a new column is being created, the first
        // operand is always a column
        targetVal = inRel[i][operands[0].__VAL__];
      } else {
        if (operands[0].__TYPE__ === 'col') {
          targetVal = inRel[i][targetCol].sdiv(inRel[i][operands[0].__VAL__]);
        } else {
          targetVal = inRel[i][targetCol].cdiv(operands[0].__VAL__);
        }
      }

      for (let j = 1; j < operands.length; j++) {
        if (operands[j].__TYPE__ === "col") {
          targetVal = targetVal.div(inRel[i][operands[j].__VAL__]);
        } else {
          targetVal = targetVal.div(operands[j].__VAL__);
        }
      }

      if (newCol) {
        let newRow = inRel[i].concat([targetVal]);
        ret.push(newRow);
      } else {
        inRel[i][targetCol] = targetVal;
        ret.push(inRel[i]);
      }
    }

    return [ret, keepRowsResult];
  }

  exports.limit = function (inRel, keepRows, num) {

    let ret = inRel.slice(0, num);
    let keepRowsResult = keepRows.slice(0, num);

    return [ret, keepRowsResult];
  }

  exports.distinct = async function (inRel, keepRows, keyCol, jiffInstance) {

    let newRel = [];
    for (let i = 0; i < inRel.length; i++) {
      newRel.push([inRel[i][keyCol]]);
    }

    let sorted = await exports.bubbleSort(newRel, keepRows, keyCol, jiffInstance);
    let sortedData = sorted[0];
    let sortedKeepRows = sorted[1];

    for (let i = 0; i < sortedData.length - 1; i++) {
      let step = jiffInstance.start_barrier();

      let a = sortedData[i][keyCol];
      let b = sortedData[i+1][keyCol];
      let dataCmp = a.eq(b);

      let keepSum = keepRows[i].sadd(sortedKeepRows[i+1]);
      // at least one keepRows index represents valid data
      let atLeastOne = keepSum.gteq(1);

      // if dataCmp is true and at least on keepRows index
      // is equal to 1, then we want the one at i to be 0,
      // and the one at i+1 to be 1. Else, do nothing
      let firstIdx = atLeastOne.if_else(0, sortedKeepRows[i]);
      let secondIdx = atLeastOne.if_else(1, sortedKeepRows[i+1]);

      // apply conditions above to dataCmp
      sortedKeepRows[i] = dataCmp.if_else(firstIdx, sortedKeepRows[i]);
      sortedKeepRows[i+1] = dataCmp.if_else(secondIdx, sortedKeepRows[i+1]);

      await jiffInstance.end_barrier(step);
    }

    return [sortedData, sortedKeepRows];
  }

  exports._compareGt = function (value, against) {
    return value.gt(against);
  }

  exports._compareGteq = function (value, against) {
    return value.gteq(against);
  }

  exports._compareLt = function (value, against) {
    return value.lt(against);
  }

  exports._compareLteq = function (value, against) {
    return value.lteq(against);
  }

  exports._compareEq = function (value, against) {
    return value.eq(against);
  }

  exports._resolveCompareFn = function (operator) {

    if (operator === '>') {
      return exports._compareGt;
    } else if (operator === '>=') {
      return exports._compareGteq;
    } else if (operator === '<') {
      return exports._compareLt;
    } else if (operator === '<=') {
      return exports._compareLteq;
    } else if (operator === '==') {
      return exports._compareEq;
    } else {
      throw `Unrecognized operator for filterAgainstScalar function: ${operator}`
    }
  }


  exports.filterAgainstCol = function (inRel, keepRows, keyCol, againstCol, operator) {

    let compareFn = exports._resolveCompareFn(operator);
    let keepRowsResult = [];

    for (let i = 0; i < inRel.length; i++) {
      let dataCmp = compareFn(inRel[i][keyCol], inRel[i][againstCol]);
      let keepRes = keepRows[i].mult(dataCmp);
      keepRowsResult.push(keepRes);
    }

    return [inRel, keepRowsResult];
  }

  exports.filterAgainstScalar = function (inRel, keepRows, keyCol, scalar, operator) {

    let compareFn = exports._resolveCompareFn(operator);
    let keepRowsResult = [];

    for (let i = 0; i < inRel.length; i++) {
      let dataCmp = compareFn(inRel[i][keyCol], scalar);
      let keepRes = keepRows[i].mult(dataCmp);
      keepRowsResult.push(keepRes);
    }

    return [inRel, keepRowsResult];
  }

  exports._bubbleSort = async function (inRel, keepRows, keyCol, jiffInstance, numCols, minVal, maxVal) {
    let loop = jiffInstance.start_barrier();
    for (let i = minVal; i < maxVal; i++) {
      let a = inRel[i][keyCol];
      let b = inRel[i+1][keyCol];
      let cmp = a.slt(b);

      for (let j = 0; j < numCols; j++) {
        let tempOne = cmp.if_else(inRel[i][j], inRel[i+1][j]);
        let tempTwo = cmp.if_else(inRel[i+1][j], inRel[i][j]);

        inRel[i][j] = tempOne;
        inRel[i+1][j] = tempTwo;
      }

      let keepOne = cmp.if_else(keepRows[i], keepRows[i+1]);
      let keepTwo = cmp.if_else(keepRows[i+1], keepRows[i]);

      keepRows[i] = keepOne;
      keepRows[i+1] = keepTwo;
    }
    await jiffInstance.end_barrier(loop);
  }

  exports.bubbleSort = async function (inRel, keepRows, keyCol, jiffInstance) {

    let numCols = inRel[0].length;
    for (let i = 0; i < inRel.length; i++) {
      let minVal;
      let maxVal;

      let totalRows = inRel.length - i - 1;
      let chunks = Math.floor(totalRows/20);
      if (chunks > 0) {
        for (let j = 0; j < chunks; j++) {
          minVal = 20 * j;
          maxVal = minVal + 20;
          await exports._bubbleSort(inRel, keepRows, keyCol, jiffInstance, numCols, minVal, maxVal);
        }
        // finish last bit
        await exports._bubbleSort(inRel, keepRows, keyCol, jiffInstance, numCols, maxVal, totalRows);
      } else {
        await exports._bubbleSort(inRel, keepRows, keyCol, jiffInstance, numCols, 0, totalRows);
      }
    }
    return [inRel, keepRows];
  }

  exports.numRows = function (keepRows) {

    let ret = keepRows[0];
    for (let i = 1; i < keepRows.length; i++) {
      ret = ret.sadd(keepRows[i]);
    }

    // if return value is greater than 0, at least 1 row was valid.
    let keepRowsResult = ret.gteq(1);

    return [[[ret]], [keepRowsResult]];
  }

  exports.concat = function (inRels, keepRows) {

    let ret = [];
    let keepRowsResult = [];
    for (let i = 0; i < inRels.length; i++) {
      for (let j = 0; j < inRels[i].length; j++) {
        ret.push(inRels[i][j]);
        keepRowsResult.push(keepRows[i][j]);
      }
    }

    return [ret, keepRowsResult];
  }

  exports.join = function (leftRel, rightRel, leftKeepRows, rightKeepRows, leftKeyCol, rightKeyCol) {

    let ret = [];
    let keepRowsResult = [];

    for (let i = 0; i < leftRel.length; i++) {
      for (let j = 0; j < rightRel.length; j++) {

        let leftJoinCol = leftRel[i][leftKeyCol];
        let rightJoinCol = rightRel[j][rightKeyCol];

        let newLeft = leftRel[i].slice();
        let newRight = rightRel[j].slice();

        newLeft.splice(leftKeyCol, 1);
        newRight.splice(rightKeyCol, 1);
        let newRow = [leftJoinCol].concat(newLeft).concat(newRight);
        ret.push(newRow);

        let eqFlag = leftJoinCol.seq(rightJoinCol);
        let keepRowsFlag = leftKeepRows[i].smult(rightKeepRows[j]).smult(eqFlag);
        keepRowsResult.push(keepRowsFlag);
      }
    }

    return [ret, keepRowsResult];
  }

  exports.open = function (inRel, keepRows, jiffInstance) {

    let results = jiffInstance.open_ND_array(inRel);
    let keepRowsResult = jiffInstance.open_array(keepRows);

    return Promise.all([results, keepRowsResult]).then(function (arr) {
      let openedRes = arr[0];
      let openedKeep = arr[1];
      let ret = [];

      for (let i = 0; i < openedRes.length; i++) {
        if (Number(openedKeep[i])) {
          ret.push(openedRes[i]);
        }
      }

      return ret;
    });
  };

}(typeof exports === 'undefined' ? this.methods = {} : exports));